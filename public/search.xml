<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leaking domain knowledge to tests - Anti-pattern</title>
      <link href="/2024/06/17/leaking-domain-knowledge-antipattern/"/>
      <url>/2024/06/17/leaking-domain-knowledge-antipattern/</url>
      
        <content type="html"><![CDATA[<p><img src="/uploads/leaking-domain-knowledge-antipattern/cover.png" alt="Alt Text"><br>Leaking domain knowledge to tests is an anti-pattern in software development and testing. It occurs when the test code contains information about the implementation details of the system under test (SUT) rather than focusing on its behavior and expected outcomes. This can lead to a number of issues that undermine the effectiveness and maintainability of the tests.</p><span id="more"></span><p>It usually, takes place in tests that cover complex algorithms.<br>Let’s look at the following simple example.</p><p>Example 1:</p><figure class="highlight csharp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> value1, <span class="built_in">int</span> value2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> value1 + value2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>We have the <em><strong>Calculator</strong></em> class with a single <em><strong>Add</strong></em> method.<br>Let’s try to write an unit test.</p><p>Example 2: An incorrect way ❌</p><figure class="highlight csharp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Fact</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Adding_two_numbers</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> value1 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> value2 = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> expected = value1 + value2;   <span class="comment">//   &lt;--- The leakage</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> actual = Calculator.Add(value1, value2);</span><br><span class="line">        Assert.Equal(expected, actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>It looks fine, but, <em><strong>it is an anti-pattern</strong></em> because we repeat the algorithm from the <em><strong>Calculator</strong></em> class in our test method:</p><figure class="highlight csharp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> expected = value1 + value2;</span><br></pre></td></tr></table></div></figure><p>Imagine that some changes will be made to the algorithm of the <em><strong>Add</strong></em> method from the <em><strong>Calculator</strong></em> class. Therefore, it will be necessary to make the same change in the unit test. So this is the biggest problem: Weak resistance to refactoring.</p><p>How to test the algorithm properly, then !?<br>So, instead of duplicating the algorithm, hard-code its expected results into the test, as demonstrated in the following example.</p><p>Example 3: A correct way ✔️</p><figure class="highlight csharp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Theory</span>]</span><br><span class="line">    [<span class="meta">InlineData(1, 3, 4)</span>]</span><br><span class="line">    [<span class="meta">InlineData(11, 33, 44)</span>]</span><br><span class="line">    [<span class="meta">InlineData(100, 500, 600)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Adding_two_numbers</span>(<span class="params"><span class="built_in">int</span> value1, <span class="built_in">int</span> value2, <span class="built_in">int</span> expected</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> actual = Calculator.Add(value1, value2);</span><br><span class="line">        Assert.Equal(expected, actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>This example I found in Vladimir Khorikov’s book - ‘Unit Testing Principles, Practices, and Patterns’. It is indeed highly recommended for anyone interested in improving their understanding and practice of unit testing. It provides valuable insights, practical advice, and best practices for writing effective unit tests.</p><p>Key Characteristics of the Antipattern</p><ol><li><p><em><strong>Implementation Details in Tests</strong></em>: Tests include specifics about how the code is implemented rather than what it should do. For example, knowing the exact data structures or internal workings of the functions being tested.</p></li><li><p><em><strong>Tight Coupling</strong></em>: Tests become tightly coupled to the implementation. If the implementation changes, even if the external behavior remains the same, the tests break and need to be updated.</p></li><li><p><em><strong>Reduced Readability</strong></em>: Tests become harder to understand because they include complex implementation details that are not necessary for understanding the expected behavior.</p></li><li><p><em><strong>Fragility</strong></em>: Tests become fragile and more prone to failure due to minor changes in the codebase that do not affect the overall functionality but alter the internal implementation.</p></li><li><p><em><strong>Limited Refactoring</strong></em>: Developers are discouraged from refactoring code, as such changes would require corresponding changes in the test code, making refactoring a more daunting task.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> unit testing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unit testing </tag>
            
            <tag> anti-pattern </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
